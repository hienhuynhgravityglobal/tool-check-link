<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Link # and /# Character Checker</title>
    <!-- External libraries for export functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
        }
        .form-container {
            margin-bottom: 20px;
            display: flex;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            font-size: 16px;
            border: none;
            flex: 1;
            outline: none;
        }
        #checkButton,
        .page-item button {
            padding: 12px 20px;
            font-size: 16px;
            background-color: #ff7043;
            color: white;
            border: none;
            cursor: pointer;
            margin-bottom: 0;
            white-space: nowrap;
            transition: background-color 0.3s;
        }
        .page-item button {
            width: 121px;
        }
        #checkButton:hover,
        .page-item button:hover,
        .collapse-btn:hover {
            background-color: #f4511e;
            cursor: pointer;
        }
        #checkButton:disabled,
        .page-item button:disabled,
        .collapse-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .pages-container {
            padding: 20px;
            background: #F3F5F9;
            margin-bottom: 20px;
            border-radius: 5px;
            border-left: 4px solid #5ebff3;
        }
        .pages-container:empty {
            padding: 0;
        }
        .results {
            margin-top: 20px;
        }
        .result-item {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .result-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .link-text-parts {
            display: inline-block;
            background-color: #f9f9f9;
            padding: 5px 10px;
            border-radius: 4px;
            margin: 5px 0;
            line-height: 1.5;
        }
        .link-text-part {
            display: inline-block;
            margin-right: 5px;
            margin-bottom: 3px;
        }
        .link-text-separator {
            color: #ff7043;
            font-weight: bold;
            margin: 0 5px;
        }
        .result-item.has-hash {
            background-color: #ffeb3b10;
            border-left: 3px solid #ffc107;
        }
        .loading {
            display: none;
            margin-top: 10px;
        }
        .stats {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #2196F3;
        }
        .stats p {
            margin: 5px 0;
        }
        .note {
            background-color: #ffeb3b50;
            padding: 10px 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #ffc107;
        }
        .sitemap-container {
            margin-bottom: 70px;
        }
        .sitemap-container h3 {
            background-color: #f1f1f1;
            padding: 10px;
            margin-top: 30px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .page-item {
            padding: 15px;
            padding-right: 135px;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee; 
        }
        .page-item.has-hash {
            background-color: white;
            position: relative;
            border-radius: 15px;
            margin-bottom: 15px;
        }
        .collapse-btn {
            margin-left: 10px;
            position: absolute;
            right: 0;
            top: 0;
            border-top-right-radius: 15px;
            border-bottom-right-radius: 15px;
            height: 100%;
            width: 119px;
            text-align: center;
            border: none;
            background: #ff7043;
            color: white;
            font-size: 16px;
        }
        .progress-container {
            margin: 20px 0;
            width: 100%;
            max-width: 1080px;
            background-color: #f1f1f1;
            border-radius: 20px;
            padding: 8px;
        }
        .progress-bar {
            height: 20px;
            width: 0%;
            background-color: #4CAF50;
            border-radius: 20px;
            transition: width 0.5s;
            text-align: center;
            line-height: 20px;
            color: white;
            font-size: 12px;
        }
        .summary-box {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #2196F3;
        }
        .hash-links-section {
            overflow: hidden;
            transition: height 0.4s ease;
            height: 0;
        }
        .stage-container {
            display: flex;
            align-items: stretch;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            background-color: #fff;
        }
        .stage-number {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            width: 70px;
            padding: 15px;
        }
        .stage-content {
            flex: 1;
            padding: 15px 20px;
        }
        .stage-content h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 18px;
        }
        .stage-content p {
            margin: 0;
            color: #666;
            font-size: 14px;
        }
        .stage-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 70px;
            background-color: rgba(255,255,255,0.2);
        }
        .stage-icon img {
            width: 32px;
            height: 32px;
        }
        .stage-1 {
            background-color: #ff6347;
        }
        .stage-2 {
            background-color: #ffa726;
        }
        .stage-3 {
            background-color: #772fc9;
        }
        .stage-4 {
            background-color: #29b6f6;
        }
        .stage-5 {
            background-color: #66bb6a;
        }
        .sitemap-url {
            word-break: break-all;
        }
        .header-links-container {
            background-color: #e8f5e9;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
        }
        .header-page-item {
            background-color: #f1f8e9;
            position: relative;
            border-radius: 15px;
            margin-bottom: 15px;
            padding: 15px;
            padding-right: 135px;
            border-bottom: 1px solid #c5e1a5;
        }
        .footer-links-container {
            background-color: #e3f2fd;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }
        .footer-page-item {
            background-color: #e8f4f8;
            position: relative;
            border-radius: 15px;
            margin-bottom: 15px;
            padding: 15px;
            padding-right: 135px;
            border-bottom: 1px solid #90caf9;
        }
        .no-links-notice {
            background-color: #ffecb3;
            padding: 10px 15px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 4px solid #ffc107;
        }
        .toggle-container {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            max-width: 870px;
            margin-left: auto;
            margin-right: auto;
            padding: 15px;
            border-radius: 5px;
            background-color: #f5f5f5;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin-right: 15px;
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .toggle-slider {
            background-color: #772fc9;
        }
        input:focus + .toggle-slider {
            box-shadow: 0 0 1px #772fc9;
        }
        input:checked + .toggle-slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }
        .toggle-label {
            font-size: 16px;
        }
        .broken-links-container {
            background-color: #ffebee;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            border-left: 4px solid #f44336;
            display: none;
        }
        .broken-page-item {
            background-color: #fff;
            position: relative;
            border-radius: 15px;
            margin-bottom: 15px;
            padding: 15px;
            padding-right: 135px;
            border-bottom: 1px solid #ffcdd2;
        }
        .broken-link-details {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff8f8;
            border-radius: 5px;
        }
        .broken-link-status {
            display: inline-block;
            padding: 4px 8px;
            margin-left: 10px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background-color: #f44336;
            border-radius: 3px;
        }
        .broken-link-source {
            margin-top: 8px;
            font-style: italic;
            color: #777;
        }
        .export-container {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            text-align: center;
            border-left: 4px solid #4CAF50;
            max-width: 870px;
            margin-left: auto;
            margin-right: auto;
            display: none;
        }
        .export-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }
        .export-btn {
            padding: 12px 25px;
            font-size: 16px;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: opacity 0.3s;
        }
        .export-btn:hover {
            opacity: 0.9;
        }
        .excel-btn {
            background-color: #217346;
        }
        .csv-btn {
            background-color: #ff9800;
        }
        .export-btn img {
            width: 20px;
            height: 20px;
        }
    </style>
</head>
<body>
    <h1>Tool check for Link # and /# Characters</h1>
    
    <div class="form-container">
        <input type="text" id="urlInput" placeholder="Enter sitemap URL (e.g., https://example.com/sitemap_index.xml)" required>
        <button type="submit" id="checkButton">Process Now</button>
    </div>

    <!-- <div class="toggle-container">
        <label class="toggle-switch">
            <input type="checkbox" id="checkBrokenLinks">
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Allow to check broken links (this will make scanning slower)</span>
    </div> -->

    <div id="loading" class="loading">Processing, please wait... This may take a while for large sitemaps.</div>
    
    <div id="progressContainer" class="progress-container" style="display: none;">
        <div id="progressBar" class="progress-bar">0%</div>
    </div>
    
    <div class="results">
        <div id="summary"></div>
        <div id="results"></div>
    </div>
    
    <div class="export-container" id="exportContainer">
        <h3>Export Results</h3>
        <p>Download your hash links data in the following formats:</p>
        <div class="export-buttons">
            <button class="export-btn excel-btn" id="excelExportBtn">
                <i class="fa-solid fa-file-excel"></i> Excel
            </button>
            <button class="export-btn csv-btn" id="csvExportBtn">
                <i class="fa-solid fa-file-csv"></i> CSV
            </button>
        </div>
    </div>

    <script>
        // Global variables to track progress
        let totalPagesToCheck = 0;
        let pagesChecked = 0;
        let pagesWithHash = 0;
        let totalHashLinks = 0;
        let headerHashLinks = new Map(); // Map to store unique header hash links
        let footerHashLinks = new Map(); // Map to store unique footer hash links
        let isCancelled = false;
        
        document.getElementById('checkButton').addEventListener('click', async function() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) return;
            
            // Reset state
            totalPagesToCheck = 0;
            pagesChecked = 0;
            pagesWithHash = 0;
            totalHashLinks = 0;
            headerHashLinks.clear(); // Clear header hash links
            footerHashLinks.clear(); // Clear footer hash links
            isCancelled = false;
            
            const loading = document.getElementById('loading');
            const checkButton = document.getElementById('checkButton');
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            
            // Clear previous results
            resultsDiv.innerHTML = '';
            summaryDiv.innerHTML = '';
            
            // Show loading and progress
            loading.style.display = 'block';
            progressContainer.style.display = 'block';
            checkButton.disabled = true;
            checkButton.innerText = 'Processing...';
            
            try {
                // Step 1: Process the sitemap index
                summaryDiv.innerHTML = `<div class="stage-container"><div class="stage-number stage-1">01</div><div class="stage-content"><h3>Stage 1: Processing sitemap index...</h3><p>Processing the sitemap index to find all sitemaps...</p></div></div>`;
                const indexResult = await processSitemapIndex(url);
                
                if (!indexResult.success) {
                    throw new Error(indexResult.error || 'Failed to process sitemap index');
                }
                
                // Always add Stage 2 to the summary div (not results div)
                const stage2Container = document.createElement('div');
                stage2Container.className = 'stage-container';
                
                // Step 2: Process individual sitemaps or the single sitemap
                if (indexResult.isSitemapIndex && indexResult.sitemaps.length > 0) {
                    // If it's a sitemap index
                    stage2Container.innerHTML = `<div class="stage-number stage-2">02</div><div class="stage-content"><h3>Stage 2: Processing ${indexResult.sitemaps.length} sitemaps...</h3><p>Processing ${indexResult.sitemaps.length} sitemaps...</p></div></div>`;
                    summaryDiv.appendChild(stage2Container);
                    
                    // Create a container for sitemap sections
                    const sitemapContainer = document.createElement('div');
                    sitemapContainer.className = 'sitemap-container';
                    resultsDiv.appendChild(sitemapContainer);
                    
                    // Process each sitemap to get page URLs
                    const allPages = [];
                    for (let i = 0; i < indexResult.sitemaps.length; i++) {
                        if (isCancelled) break;
                        
                        const sitemap = indexResult.sitemaps[i];
                        const sitemapResult = await processSitemap(sitemap.loc);
                        
                        if (sitemapResult.success && sitemapResult.pages.length > 0) {
                            const sitemapSection = document.createElement('div');
                            sitemapSection.innerHTML = `
                                <h3>Sitemap ${i+1}: <span class="sitemap-url">${sitemap.loc}</span></h3>
                                <p>Found ${sitemapResult.pages.length} pages</p>
                            `;
                            sitemapContainer.appendChild(sitemapSection);
                            
                            allPages.push(...sitemapResult.pages);
                        }
                        
                        // Update progress
                        const sitemapProgress = ((i + 1) / indexResult.sitemaps.length) * 30;
                        progressBar.style.width = `${sitemapProgress}%`;
                        progressBar.innerText = `Processing sitemaps: ${i+1}/${indexResult.sitemaps.length}`;
                    }
                    
                    // Step 3: Check each page for # links
                    totalPagesToCheck = allPages.length;
                    summaryDiv.innerHTML += `<div class="stage-container"><div class="stage-number stage-3">03</div><div class="stage-content"><h3>Stage 3: Checking ${totalPagesToCheck} pages for # links...</h3><p>Checking ${totalPagesToCheck} pages for # links...</p></div></div>`;
                    
                    // Create container for pages with hash links
                    const pagesContainer = document.createElement('div');
                    pagesContainer.className = 'pages-container';
                    pagesContainer.innerHTML = '<h3>Hash Links in Regular Content</h3>';
                    resultsDiv.appendChild(pagesContainer);
                    
                    // Create container for header links
                    const headerLinksContainer = document.createElement('div');
                    headerLinksContainer.className = 'header-links-container';
                    headerLinksContainer.innerHTML = '<h3>Hash Links in Headers (Across All Pages)</h3>';
                    resultsDiv.appendChild(headerLinksContainer);
                    
                    // Create container for footer links
                    const footerLinksContainer = document.createElement('div');
                    footerLinksContainer.className = 'footer-links-container';
                    footerLinksContainer.innerHTML = '<h3>Hash Links in Footers (Across All Pages)</h3>';
                    resultsDiv.appendChild(footerLinksContainer);
                    
                    // Create container for broken links
                    const brokenLinksContainer = document.createElement('div');
                    brokenLinksContainer.className = 'broken-links-container';
                    brokenLinksContainer.innerHTML = '<h3>Broken Links Found</h3>';
                    resultsDiv.appendChild(brokenLinksContainer);
                    
                    /* Example of how to add a broken link item:
                    const brokenPageItem = document.createElement('div');
                    brokenPageItem.className = 'broken-page-item';
                    brokenPageItem.innerHTML = `
                        <a href="https://example.com/broken-page" target="_blank">https://example.com/broken-page</a>
                        <span class="broken-link-status">404</span>
                        <button class="collapse-btn" onclick="toggleHashLinks(this)">Show Details</button>
                        <div class="hash-links-section" style="height: 0px; padding: 0px;">
                            <div class="broken-link-details">
                                <strong>Found on:</strong> <a href="https://example.com/source-page" target="_blank">https://example.com/source-page</a>
                                <div class="broken-link-source">
                                    <strong>Link Text:</strong> Example Broken Link
                                </div>
                                <div class="broken-link-source">
                                    <strong>Last Checked:</strong> 2023-05-15 14:30:25
                                </div>
                            </div>
                        </div>
                    `;
                    brokenLinksContainer.appendChild(brokenPageItem);
                    */
                    
                    // Process pages in batches to avoid overwhelming the server
                    const batchSize = 5;
                    for (let i = 0; i < allPages.length; i += batchSize) {
                        if (isCancelled) break;
                        
                        const batch = allPages.slice(i, i + batchSize);
                        const batchPromises = batch.map(page => checkPageForHash(page.loc));
                        const batchResults = await Promise.all(batchPromises);
                        
                        for (const result of batchResults) {
                            pagesChecked++;
                            
                            // Process header hash links first
                            if (result.success && result.hasHeaderHashLinks) {
                                // Add unique header links to the global map - use only TEXT as the key
                                result.headerHashLinks.forEach(link => {
                                    const linkKey = `${link.text}`; // Only use text for header links
                                    if (!headerHashLinks.has(linkKey)) {
                                        headerHashLinks.set(linkKey, {
                                            text: link.text,
                                            href: link.href,
                                            context: link.context,
                                            headerType: link.headerType,
                                            urls: [result.url]
                                        });
                                    } else {
                                        // Add this URL to existing link's URLs if not already there
                                        const existingLink = headerHashLinks.get(linkKey);
                                        if (!existingLink.urls.includes(result.url)) {
                                            existingLink.urls.push(result.url);
                                        }
                                    }
                                });
                                
                                // Update header links display
                                updateHeaderLinksDisplay(headerLinksContainer);
                            }
                            
                            // Process footer hash links
                            if (result.success && result.hasFooterHashLinks) {
                                // Add unique footer links to the global map
                                result.footerHashLinks.forEach(link => {
                                    const linkKey = `${link.text}-${link.href}-${link.footerType}`;
                                    if (!footerHashLinks.has(linkKey)) {
                                        footerHashLinks.set(linkKey, {
                                            text: link.text,
                                            href: link.href,
                                            context: link.context,
                                            footerType: link.footerType,
                                            urls: [result.url]
                                        });
                                    } else {
                                        // Add this URL to existing link's URLs if not already there
                                        const existingLink = footerHashLinks.get(linkKey);
                                        if (!existingLink.urls.includes(result.url)) {
                                            existingLink.urls.push(result.url);
                                        }
                                    }
                                });
                                
                                // Update footer links display
                                updateFooterLinksDisplay(footerLinksContainer);
                            }
                            
                            // Process regular hash links
                            if (result.success && result.hasHashLinks) {
                                pagesWithHash++;
                                totalHashLinks += result.hashLinks.length;
                                
                                // Add to the results
                                const pageItem = document.createElement('div');
                                pageItem.className = 'page-item has-hash';
                                
                                let hashLinksHtml = '';
                                result.hashLinks.forEach(link => {
                                    hashLinksHtml += `
                                        <div class="result-item has-hash">
                                            <strong>Link Text:</strong> ${formatPipeSeparatedText(link.text)}<br>
                                            <strong>HREF:</strong> ${link.href}<br>
                                            <strong>Context:</strong> ${link.context || 'No context available'}
                                        </div>
                                    `;
                                });
                                
                                pageItem.innerHTML = `
                                    <a href="${result.url}" target="_blank">${result.url}</a>
                                    <strong> (Found ${result.hashLinks.length} links)</strong>
                                    <button class="collapse-btn" onclick="toggleHashLinks(this)">Show Links</button>
                                    <div class="hash-links-section" style="height: 0px; padding: 0px;">
                                        ${hashLinksHtml}
                                    </div>
                                `;
                                
                                pagesContainer.appendChild(pageItem);
                            }
                            
                            // Update progress
                            const pageProgress = 30 + ((pagesChecked / totalPagesToCheck) * 70);
                            progressBar.style.width = `${pageProgress}%`;
                            progressBar.innerText = `Checking pages: ${pagesChecked}/${totalPagesToCheck}`;
                            
                            // Update live summary
                            updateLiveSummary();
                        }
                    }
                    
                    // After processing all pages, check if we found any links in regular pages
                    if (pagesWithHash === 0) {
                        const noRegularLinks = document.createElement('p');
                        noRegularLinks.className = 'no-links-notice';
                        noRegularLinks.innerHTML = '<strong>No hash links (#, /#) were found in regular page content.</strong>';
                        pagesContainer.appendChild(noRegularLinks);
                    }
                    
                    // Show final summary
                    showFinalSummary();
                    
                } else if (!indexResult.isSitemapIndex && indexResult.pages && indexResult.pages.length > 0) {
                    // If the input was a regular sitemap, not an index
                    // Still show Stage 2, but indicate it's a regular sitemap
                    stage2Container.innerHTML = `<div class="stage-number stage-2">02</div><div class="stage-content"><h3>Stage 2: Processing sitemap</h3><p>Processing a regular sitemap (not an index)...</p></div></div>`;
                    summaryDiv.appendChild(stage2Container);
                    
                    // Now show Stage 3
                    summaryDiv.innerHTML += `<div class="stage-container"><div class="stage-number stage-3">03</div><div class="stage-content"><h3>Stage 3: Checking ${indexResult.pages.length} pages for # links...</h3><p>Checking ${indexResult.pages.length} pages for # links...</p></div></div>`;
                    
                    totalPagesToCheck = indexResult.pages.length;
                    
                    // Create container for pages with hash links
                    const pagesContainer = document.createElement('div');
                    pagesContainer.className = 'pages-container';
                    pagesContainer.innerHTML = '<h3>Hash Links in Regular Content</h3>';
                    resultsDiv.appendChild(pagesContainer);
                    
                    // Create container for header links
                    const headerLinksContainer = document.createElement('div');
                    headerLinksContainer.className = 'header-links-container';
                    headerLinksContainer.innerHTML = '<h3>Hash Links in Headers (Across All Pages)</h3>';
                    resultsDiv.appendChild(headerLinksContainer);
                    
                    // Create container for footer links
                    const footerLinksContainerRegular = document.createElement('div');
                    footerLinksContainerRegular.className = 'footer-links-container';
                    footerLinksContainerRegular.innerHTML = '<h3>Hash Links in Footers (Across All Pages)</h3>';
                    resultsDiv.appendChild(footerLinksContainerRegular);
                    
                    // Create container for broken links
                    const brokenLinksContainerRegular = document.createElement('div');
                    brokenLinksContainerRegular.className = 'broken-links-container';
                    brokenLinksContainerRegular.innerHTML = '<h3>Broken Links Found</h3>';
                    resultsDiv.appendChild(brokenLinksContainerRegular);
                    
                    // Process pages in batches
                    const batchSize = 5;
                    for (let i = 0; i < indexResult.pages.length; i += batchSize) {
                        if (isCancelled) break;
                        
                        const batch = indexResult.pages.slice(i, i + batchSize);
                        const batchPromises = batch.map(page => checkPageForHash(page.loc));
                        const batchResults = await Promise.all(batchPromises);
                        
                        for (const result of batchResults) {
                            pagesChecked++;
                            
                            // Process header hash links first
                            if (result.success && result.hasHeaderHashLinks) {
                                // Add unique header links to the global map - use only TEXT as the key
                                result.headerHashLinks.forEach(link => {
                                    const linkKey = `${link.text}`; // Only use text for header links
                                    if (!headerHashLinks.has(linkKey)) {
                                        headerHashLinks.set(linkKey, {
                                            text: link.text,
                                            href: link.href,
                                            context: link.context,
                                            headerType: link.headerType,
                                            urls: [result.url]
                                        });
                                    } else {
                                        // Add this URL to existing link's URLs if not already there
                                        const existingLink = headerHashLinks.get(linkKey);
                                        if (!existingLink.urls.includes(result.url)) {
                                            existingLink.urls.push(result.url);
                                        }
                                    }
                                });
                                
                                // Update header links display
                                updateHeaderLinksDisplay(headerLinksContainer);
                            }
                            
                            // Process footer hash links
                            if (result.success && result.hasFooterHashLinks) {
                                // Add unique footer links to the global map
                                result.footerHashLinks.forEach(link => {
                                    const linkKey = `${link.text}-${link.href}-${link.footerType}`;
                                    if (!footerHashLinks.has(linkKey)) {
                                        footerHashLinks.set(linkKey, {
                                            text: link.text,
                                            href: link.href,
                                            context: link.context,
                                            footerType: link.footerType,
                                            urls: [result.url]
                                        });
                                    } else {
                                        // Add this URL to existing link's URLs if not already there
                                        const existingLink = footerHashLinks.get(linkKey);
                                        if (!existingLink.urls.includes(result.url)) {
                                            existingLink.urls.push(result.url);
                                        }
                                    }
                                });
                                
                                // Update footer links display
                                updateFooterLinksDisplay(footerLinksContainerRegular);
                            }
                            
                            // Process regular hash links
                            if (result.success && result.hasHashLinks) {
                                pagesWithHash++;
                                totalHashLinks += result.hashLinks.length;
                                
                                // Add to the results
                                const pageItem = document.createElement('div');
                                pageItem.className = 'page-item has-hash';
                                
                                let hashLinksHtml = '';
                                result.hashLinks.forEach(link => {
                                    hashLinksHtml += `
                                        <div class="result-item has-hash">
                                            <strong>Link Text:</strong> ${formatPipeSeparatedText(link.text)}<br>
                                            <strong>HREF:</strong> ${link.href}<br>
                                            <strong>Context:</strong> ${link.context || 'No context available'}
                                        </div>
                                    `;
                                });
                                
                                pageItem.innerHTML = `
                                    <a href="${result.url}" target="_blank">${result.url}</a>
                                    <strong> (Found ${result.hashLinks.length} links)</strong>
                                    <button class="collapse-btn" onclick="toggleHashLinks(this)">Show Links</button>
                                    <div class="hash-links-section" style="height: 0px; padding: 0px;">
                                        ${hashLinksHtml}
                                    </div>
                                `;
                                
                                pagesContainer.appendChild(pageItem);
                            }
                            
                            // Update progress
                            const pageProgress = ((pagesChecked / totalPagesToCheck) * 100);
                            progressBar.style.width = `${pageProgress}%`;
                            progressBar.innerText = `Checking pages: ${pagesChecked}/${totalPagesToCheck}`;
                            
                            // Update live summary
                            updateLiveSummary();
                        }
                    }
                    
                    // After processing all pages, check if we found any links in regular pages
                    if (pagesWithHash === 0) {
                        const noRegularLinks = document.createElement('p');
                        noRegularLinks.className = 'no-links-notice';
                        noRegularLinks.innerHTML = '<strong>No hash links (#, /#) were found in regular page content.</strong>';
                        pagesContainer.appendChild(noRegularLinks);
                    }
                    
                    // Show final summary
                    showFinalSummary();
                } else {
                    throw new Error('No pages found in the sitemap');
                }
                
            } catch (error) {
                console.error('Error:', error);
                summaryDiv.innerHTML = `<h2>Error: ${error.message}</h2>`;
            } finally {
                // Always hide loading and reset button
                loading.style.display = 'none';
                checkButton.disabled = false;
                checkButton.innerText = 'Process Now';
                
                // Complete progress bar
                progressBar.style.width = '100%';
                progressBar.innerText = 'Complete';
            }
        });
        
        // Function to process a sitemap index
        async function processSitemapIndex(url) {
            try {
                const response = await fetch(`/api/process-sitemap-index?url=${encodeURIComponent(url)}`);
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to process sitemap index');
                }
                
                // Handle sitemap index
                if (data.isSitemapIndex) {
                    return {
                        success: true,
                        isSitemapIndex: true,
                        sitemaps: data.sitemapUrls || []
                    };
                } 
                // Handle single sitemap
                else if (data.originalData && data.originalData.urlset && data.originalData.urlset.url) {
                    const urls = Array.isArray(data.originalData.urlset.url) 
                        ? data.originalData.urlset.url 
                        : [data.originalData.urlset.url];
                    
                    return {
                        success: true,
                        isSitemapIndex: false,
                        pages: urls.map(item => {
                            return {
                                loc: item.loc || '',
                                lastmod: item.lastmod || ''
                            };
                        })
                    };
                } else {
                    throw new Error('Invalid sitemap structure');
                }
            } catch (error) {
                console.error('Error processing sitemap index:', error);
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        // Function to process a single sitemap
        async function processSitemap(url) {
            try {
                const response = await fetch(`/api/fetch-page?url=${encodeURIComponent(url)}`);
                const data = await response.json();
                
                if (!response.ok || !data.success) {
                    throw new Error(data.error || 'Failed to fetch sitemap');
                }
                
                if (!data.isXml) {
                    throw new Error('The URL does not point to an XML sitemap');
                }
                
                // Extract pages from the sitemap
                if (data.parsedXml && data.parsedXml.urlset && data.parsedXml.urlset.url) {
                    const urls = Array.isArray(data.parsedXml.urlset.url) 
                        ? data.parsedXml.urlset.url 
                        : [data.parsedXml.urlset.url];
                    
                    return {
                        success: true,
                        pages: urls.map(item => {
                            return {
                                loc: item.loc || '',
                                lastmod: item.lastmod || ''
                            };
                        })
                    };
                } else {
                    return {
                        success: false,
                        error: 'Invalid sitemap structure',
                        pages: []
                    };
                }
            } catch (error) {
                console.error('Error processing sitemap:', error);
                return {
                    success: false,
                    error: error.message,
                    pages: []
                };
            }
        }
        
        // Function to check a single page for href="#" links
        async function checkPageForHash(url) {
            try {
                const response = await fetch(`/api/check-page-for-hash?url=${encodeURIComponent(url)}`);
                return await response.json();
            } catch (error) {
                console.error('Error checking page:', error);
                return {
                    success: false,
                    url: url,
                    error: error.message,
                    hasHashLinks: false,
                    hashLinks: [],
                    hasHeaderHashLinks: false,
                    headerHashLinks: [],
                    hasFooterHashLinks: false,
                    footerHashLinks: []
                };
            }
        }
        
        // Function to update the live summary during processing
        function updateLiveSummary() {
            const summaryDiv = document.getElementById('summary');
            
            // Check if the stage-4 container already exists
            let stageContainer = null;
            const stage4Element = summaryDiv.querySelector('.stage-4');
            if (stage4Element) {
                stageContainer = stage4Element.closest('.stage-container');
            }
            
            if (!stageContainer) {
                // Create a new stage container if it doesn't exist
                stageContainer = document.createElement('div');
                stageContainer.className = 'stage-container';
                stageContainer.innerHTML = `
                    <div class="stage-number stage-4">04</div>
                    <div class="stage-content">
                        <h3>Stage 4: Current Progress</h3>
                        <p>Live tracking of pages checked and results found</p>
                    </div>
                `;
                summaryDiv.appendChild(stageContainer);
            }
            
        }
        
        // Function to format pipe-separated text with styled separators
        function formatPipeSeparatedText(text) {
            if (!text.includes(' | ')) {
                return text;
            }
            
            const parts = text.split(' | ');
            let formattedText = '<div class="link-text-parts">';
            
            parts.forEach((part, index) => {
                formattedText += `<span class="link-text-part">${part}</span>`;
                if (index < parts.length - 1) {
                    formattedText += '<span class="link-text-separator">|</span>';
                }
            });
            
            formattedText += '</div>';
            return formattedText;
        }
        
        // Function to update the header links display
        function updateHeaderLinksDisplay(container) {
            // Clear the container except for the title
            const title = container.querySelector('h3');
            container.innerHTML = '';
            container.appendChild(title);
            
            // Add info about number of unique header links
            const headerCount = document.createElement('p');
            headerCount.innerHTML = `<strong>Found ${headerHashLinks.size} unique link texts in headers across all pages</strong>`;
            container.appendChild(headerCount);
            
            // Display each unique header link
            headerHashLinks.forEach((link, key) => {
                const headerItem = document.createElement('div');
                headerItem.className = 'header-page-item';
                
                let urlsList = '';
                link.urls.forEach(url => {
                    urlsList += `<li><a href="${url}" target="_blank">${url}</a></li>`;
                });
                
                headerItem.innerHTML = `
                    <strong>Text:</strong> ${formatPipeSeparatedText(link.text)}<br>
                    <strong>HREF:</strong> ${link.href}<br>
                    <strong>Header Type:</strong> ${link.headerType}<br>
                    <strong>Context:</strong> ${link.context}<br>
                    <strong>Found on ${link.urls.length} page(s):</strong>
                    <button class="collapse-btn" onclick="toggleHashLinks(this)">Show Pages</button>
                    <div class="hash-links-section" style="height: 0px; padding: 0px;">
                        <ul>${urlsList}</ul>
                    </div>
                `;
                
                container.appendChild(headerItem);
            });
            
            // If no header links found
            if (headerHashLinks.size === 0) {
                const noLinks = document.createElement('p');
                noLinks.className = 'no-links-notice';
                noLinks.innerHTML = '<strong>No hash links (#, /#) were found in any header elements.</strong>';
                container.appendChild(noLinks);
            }
        }
        
        // Function to update the footer links display
        function updateFooterLinksDisplay(container) {
            // Clear the container except for the title
            const title = container.querySelector('h3');
            container.innerHTML = '';
            container.appendChild(title);
            
            // Add info about number of unique footer links
            const footerCount = document.createElement('p');
            footerCount.innerHTML = `<strong>Found ${footerHashLinks.size} unique link texts in footers across all pages</strong>`;
            container.appendChild(footerCount);
            
            // Display each unique footer link
            footerHashLinks.forEach((link, key) => {
                const footerItem = document.createElement('div');
                footerItem.className = 'footer-page-item';
                
                let urlsList = '';
                link.urls.forEach(url => {
                    urlsList += `<li><a href="${url}" target="_blank">${url}</a></li>`;
                });
                
                footerItem.innerHTML = `
                    <strong>Text:</strong> ${formatPipeSeparatedText(link.text)}<br>
                    <strong>HREF:</strong> ${link.href}<br>
                    <strong>Footer Type:</strong> ${link.footerType}<br>
                    <strong>Context:</strong> ${link.context}<br>
                    <strong>Found on ${link.urls.length} page(s):</strong>
                    <button class="collapse-btn" onclick="toggleHashLinks(this)">Show Pages</button>
                    <div class="hash-links-section" style="height: 0px; padding: 0px;">
                        <ul>${urlsList}</ul>
                    </div>
                `;
                
                container.appendChild(footerItem);
            });
            
            // If no footer links found
            if (footerHashLinks.size === 0) {
                const noLinks = document.createElement('p');
                noLinks.className = 'no-links-notice';
                noLinks.innerHTML = '<strong>No hash links (#, /#) were found in any footer elements.</strong>';
                container.appendChild(noLinks);
            }
        }
        
        // Function to show the final summary
        function showFinalSummary() {
            const summaryDiv = document.getElementById('summary');
            
            // Add stage title for final results
            const stageContainer = document.createElement('div');
            stageContainer.className = 'stage-container';
            stageContainer.innerHTML = `
                <div class="stage-number stage-5">05</div>
                <div class="stage-content">
                    <h3>Stage 5: Final Results</h3>
                    <p>Summary of all pages checked and hash links found</p>
                </div>
            `;
            summaryDiv.appendChild(stageContainer);
            
            const finalSummary = document.createElement('div');
            finalSummary.className = 'summary-box';
            
            if (pagesWithHash > 0 || headerHashLinks.size > 0 || footerHashLinks.size > 0) {
                finalSummary.innerHTML = `
                    <p><strong>Total pages checked:</strong> ${pagesChecked}</p>
                    <p><strong>Pages with href="#" or href="/#" links found (excluding headers/footers):</strong> ${pagesWithHash}</p>
                    <p><strong>Total href="#" or href="/#" links found (excluding headers/footers):</strong> ${totalHashLinks}</p>
                    <p><strong>Unique link texts found in headers:</strong> ${headerHashLinks.size}</p>
                    <p><strong>Unique link texts found in footers:</strong> ${footerHashLinks.size}</p>
                    <p>Scroll down to see the results.</p>
                `;
                
                // Show export options when results are found
                document.getElementById('exportContainer').style.display = 'block';
            } else {
                finalSummary.innerHTML = `
                    <p><strong>Total pages checked:</strong> ${pagesChecked}</p>
                    <p><strong>No hash links (#, /#) were found on any of the pages.</strong></p>
                `;
            }
            
            summaryDiv.appendChild(finalSummary);
        }
        
        // Function to toggle showing/hiding hash links for a page
        function toggleHashLinks(button) {
            const section = button.nextElementSibling;
            
            if (section.style.height === "0px" || section.style.height === "") {
                section.style.padding = "10px 0 0 0";
                const sectionHeight = section.scrollHeight + "px";
                section.style.height = sectionHeight;
                button.innerText = 'Hide Links';
            } else {
                section.style.height = "0px";
                section.style.padding = "0px";
                button.innerText = 'Show Links';
            }
        }
        
        // Make the functions available globally
        window.toggleHashLinks = toggleHashLinks;
        window.updateHeaderLinksDisplay = updateHeaderLinksDisplay;
        window.updateFooterLinksDisplay = updateFooterLinksDisplay;
        
        // Export Functions
        
        // Function to prepare data for export
        function prepareExportData() {
            const data = [];
            
            // Add header for regular hash links
            if (document.querySelector('.pages-container') && document.querySelectorAll('.page-item.has-hash').length > 0) {
                data.push({
                    section: "Hash Links in Regular Content",
                    links: []
                });
                
                // Get data from regular hash links
                document.querySelectorAll('.page-item.has-hash').forEach(item => {
                    const url = item.querySelector('a')?.href || '';
                    const hashLinksItems = item.querySelectorAll('.result-item.has-hash');
                    
                    hashLinksItems.forEach(hashLink => {
                        const textElement = hashLink.innerHTML.match(/<strong>Link Text:<\/strong>(.*?)<br>/);
                        const text = textElement ? cleanHtmlText(textElement[1]) : '';
                        
                        const hrefElement = hashLink.innerHTML.match(/<strong>HREF:<\/strong>(.*?)<br>/);
                        const href = hrefElement ? hrefElement[1].trim() : '';
                        
                        data[data.length - 1].links.push({
                            text: text,
                            href: href,
                            url: url
                        });
                    });
                });
            }
            
            // Add header links
            if (headerHashLinks.size > 0) {
                data.push({
                    section: "Hash Links in Headers (Across All Pages)",
                    links: []
                });
                
                headerHashLinks.forEach((link, key) => {
                    data[data.length - 1].links.push({
                        text: link.text,
                        href: link.href,
                        url: link.urls[0] || '' // Use the first URL as example
                    });
                });
            }
            
            // Add footer links
            if (footerHashLinks.size > 0) {
                data.push({
                    section: "Hash Links in Footers (Across All Pages)",
                    links: []
                });
                
                footerHashLinks.forEach((link, key) => {
                    data[data.length - 1].links.push({
                        text: link.text,
                        href: link.href,
                        url: link.urls[0] || '' // Use the first URL as example
                    });
                });
            }
            
            return data;
        }
        
        // Helper function to clean HTML text
        function cleanHtmlText(html) {
            if (!html) return '';
            
            // Create a temporary div to extract text
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Extract text content
            let text = temp.textContent || temp.innerText || '';
            
            // Replace multiple spaces with a single space
            text = text.replace(/\s+/g, ' ').trim();
            
            return text;
        }
        
        // Function to export to Excel
        document.getElementById('excelExportBtn').addEventListener('click', function() {
            const data = prepareExportData();
            if (data.length === 0) {
                alert('No data to export.');
                return;
            }
            
            // Create workbook
            const XLSX = window.XLSX;
            const wb = XLSX.utils.book_new();
            
            // Process each section
            data.forEach(section => {
                // Convert the data to a worksheet
                const ws_data = [
                    ['Text', 'HREF', 'URL']
                ];
                
                section.links.forEach(link => {
                    ws_data.push([link.text, link.href, link.url]);
                });
                
                const ws = XLSX.utils.aoa_to_sheet(ws_data);
                
                // Add the worksheet to the workbook
                XLSX.utils.book_append_sheet(wb, ws, section.section.substring(0, 30));
            });
            
            // Generate Excel file
            XLSX.writeFile(wb, 'hash_links_report.xlsx');
        });
        
        // Function to export to CSV
        document.getElementById('csvExportBtn').addEventListener('click', function() {
            const data = prepareExportData();
            if (data.length === 0) {
                alert('No data to export.');
                return;
            }
            
            let csvContent = '';
            
            // Process each section
            data.forEach(section => {
                // Add section header as a comment
                csvContent += '# ' + section.section + '\r\n';
                csvContent += 'Text,HREF,URL\r\n';
                
                section.links.forEach(link => {
                    // Escape fields properly for CSV
                    const escapedText = '"' + (link.text || '').replace(/"/g, '""') + '"';
                    const escapedHref = '"' + (link.href || '').replace(/"/g, '""') + '"';
                    const escapedUrl = '"' + (link.url || '').replace(/"/g, '""') + '"';
                    
                    csvContent += escapedText + ',' + escapedHref + ',' + escapedUrl + '\r\n';
                });
                
                csvContent += '\r\n'; // Add space between sections
            });
            
            // Generate and download the file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "hash_links_report.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    </script>
</body>
</html> 